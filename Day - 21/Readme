ğŸ§© Problem 1: Valid Parenthesis String
ğŸ“„ Problem Statement
Given a string s containing only three types of characters: '(', ')', and '*', return true if the string is valid.

A string is valid if:

Every '(' has a matching ')'.

Every ')' has a matching '('.

Parentheses must close in correct order: '(' must come before ')'.

'*' can be treated as:

A left parenthesis '('

A right parenthesis ')'

An empty string ""

âœ… Examples
Input	Output
"()"	true
"(*)"	true
"(*))"	true

ğŸ§  Approach
We use two stacks:

One to store the indices of '('

One to store the indices of '*'

Step-by-step:
Traverse the string:

Push index of '(' to leftParenStack

Push index of '*' to starStack

When encountering ')':

Try to pop from leftParenStack (if possible)

Otherwise, pop from starStack

If both are empty â†’ invalid

After processing the string:

Match remaining '(' with any '*' that appears after them

If any '(' remains unmatched â†’ invalid

â±ï¸ Time Complexity
O(n) â€” we traverse the string once and do constant-time stack operations

ğŸ§  Space Complexity
O(n) â€” in the worst case, we store all characters in stacks

ğŸ§© Problem 2: Pascal's Triangle â€” Row Retrieval
ğŸ“„ Problem Statement
Given an integer rowIndex, return the rowIndex-th (0-indexed) row of the Pascal's Triangle.

In Pascal's Triangle, each number is the sum of the two numbers directly above it. The i-th row has i+1 elements.

âœ… Examples
Input	Output
rowIndex = 3	[1, 3, 3, 1]
rowIndex = 0	[1]
rowIndex = 1	[1, 1]

ğŸ§  Approach
We use the iterative binomial coefficient method to avoid calculating factorials directly.

Each element in the row can be calculated from the previous one using:

C(i,j)=C(i,jâˆ’1)â‹… 
j
iâˆ’j+1
â€‹
 
Steps:
Start with the first element: 1

Use the formula to compute the next element from the previous one

Push each computed value to the output vector

This is a mathematically efficient way to build the row.

â±ï¸ Time Complexity
O(n) â€” where n = rowIndex

ğŸ§  Space Complexity
O(n) â€” we only store one row of rowIndex + 1 elements
